#include "percent_encoding.h"

// Maps generated by gen_encoding_maps.py
const unsigned char bitmap_encodeURI[16] = {
    0b11111111, /* \x00 \x01 \x02 \x03 \x04 \x05 \x06 \x07 */
    0b11111111, /* \x08  \t   \n  \x0b \x0c  \r  \x0e \x0f */
    0b11111111, /* \x10 \x11 \x12 \x13 \x14 \x15 \x16 \x17 */
    0b11111111, /* \x18 \x19 \x1a \x1b \x1c \x1d \x1e \x1f */
    0b00100101, /*       !    "    #    $    %    &    '   */
    0b00000000, /*  (    )    *    +    ,    -    .    /   */
    0b00000000, /*  0    1    2    3    4    5    6    7   */
    0b01010000, /*  8    9    :    ;    <    =    >    ?   */
    0b00000000, /*  @    A    B    C    D    E    F    G   */
    0b00000000, /*  H    I    J    K    L    M    N    O   */
    0b00000000, /*  P    Q    R    S    T    U    V    W   */
    0b01111000, /*  X    Y    Z    [    \\   ]    ^    _   */
    0b00000001, /*  `    a    b    c    d    e    f    g   */
    0b00000000, /*  h    i    j    k    l    m    n    o   */
    0b00000000, /*  p    q    r    s    t    u    v    w   */
    0b10111000, /*  x    y    z    {    |    }    ~   \x7f */
};              /* Comment swapped endianess */

const unsigned char bitmap_encodeURIComponent[16] = {
    0b11111111, /* \x00 \x01 \x02 \x03 \x04 \x05 \x06 \x07 */
    0b11111111, /* \x08  \t   \n  \x0b \x0c  \r  \x0e \x0f */
    0b11111111, /* \x10 \x11 \x12 \x13 \x14 \x15 \x16 \x17 */
    0b11111111, /* \x18 \x19 \x1a \x1b \x1c \x1d \x1e \x1f */
    0b01111101, /*       !    "    #    $    %    &    '   */
    0b10011000, /*  (    )    *    +    ,    -    .    /   */
    0b00000000, /*  0    1    2    3    4    5    6    7   */
    0b11111100, /*  8    9    :    ;    <    =    >    ?   */
    0b00000001, /*  @    A    B    C    D    E    F    G   */
    0b00000000, /*  H    I    J    K    L    M    N    O   */
    0b00000000, /*  P    Q    R    S    T    U    V    W   */
    0b01111000, /*  X    Y    Z    [    \\   ]    ^    _   */
    0b00000001, /*  `    a    b    c    d    e    f    g   */
    0b00000000, /*  h    i    j    k    l    m    n    o   */
    0b00000000, /*  p    q    r    s    t    u    v    w   */
    0b10111000, /*  x    y    z    {    |    }    ~   \x7f */
};              /* Comment swapped endianess */
#ifdef NON_STANDARD_FUNC
const unsigned char bitmap_encodeNonCharNum[16] = {
    0b11111111, /* \x00 \x01 \x02 \x03 \x04 \x05 \x06 \x07 */
    0b11111111, /* \x08  \t   \n  \x0b \x0c  \r  \x0e \x0f */
    0b11111111, /* \x10 \x11 \x12 \x13 \x14 \x15 \x16 \x17 */
    0b11111111, /* \x18 \x19 \x1a \x1b \x1c \x1d \x1e \x1f */
    0b01111101, /*       !    "    #    $    %    &    '   */
    0b10011000, /*  (    )    *    +    ,    -    .    /   */
    0b00000000, /*  0    1    2    3    4    5    6    7   */
    0b11111100, /*  8    9    :    ;    <    =    >    ?   */
    0b00000001, /*  @    A    B    C    D    E    F    G   */
    0b00000000, /*  H    I    J    K    L    M    N    O   */
    0b00000000, /*  P    Q    R    S    T    U    V    W   */
    0b01111000, /*  X    Y    Z    [    \\   ]    ^    _   */
    0b00000001, /*  `    a    b    c    d    e    f    g   */
    0b00000000, /*  h    i    j    k    l    m    n    o   */
    0b00000000, /*  p    q    r    s    t    u    v    w   */
    0b10111000, /*  x    y    z    {    |    }    ~   \x7f */
};              /* Comment swapped endianess */
#endif
const unsigned char bitmap_hex[16] = {
    0b00000000, /* \x00 \x01 \x02 \x03 \x04 \x05 \x06 \x07 */
    0b00000000, /* \x08  \t   \n  \x0b \x0c  \r  \x0e \x0f */
    0b00000000, /* \x10 \x11 \x12 \x13 \x14 \x15 \x16 \x17 */
    0b00000000, /* \x18 \x19 \x1a \x1b \x1c \x1d \x1e \x1f */
    0b00000000, /*       !    "    #    $    %    &    '   */
    0b00000000, /*  (    )    *    +    ,    -    .    /   */
    0b11111111, /*  0    1    2    3    4    5    6    7   */
    0b00000011, /*  8    9    :    ;    <    =    >    ?   */
    0b01111110, /*  @    A    B    C    D    E    F    G   */
    0b00000000, /*  H    I    J    K    L    M    N    O   */
    0b00000000, /*  P    Q    R    S    T    U    V    W   */
    0b00000000, /*  X    Y    Z    [    \\   ]    ^    _   */
    0b01111110, /*  `    a    b    c    d    e    f    g   */
    0b00000000, /*  h    i    j    k    l    m    n    o   */
    0b00000000, /*  p    q    r    s    t    u    v    w   */
    0b00000000, /*  x    y    z    {    |    }    ~   \x7f */
};              /* Comment swapped endianess */

char *__encode_by_map(const char *text, const unsigned char *ascii_includes){
    // allocate memory for the worst possible case (all characters need to be encoded)
    const size_t len_text = strlen(text);
    char * const encodedText = (char *)malloc(sizeof(char)*len_text*3+1);
    
    const char *hex = "0123456789abcdef";
    int pos = 0;
    for (size_t i = 0; i < len_text; i++) {
        signed char c = (signed char) text[i];
        if (c < 0 || ! (ascii_includes[c/8] & (1<<(c%8))) ) {
                encodedText[pos++] = text[i];
            } else {
                encodedText[pos++] = '%';
                encodedText[pos++] = hex[c >> 4];
                encodedText[pos++] = hex[c & 15];
            }
    }
    encodedText[pos] = '\0';
    return encodedText;
}

/*
 * Encodes everything EXCEPT
 *     A–Z a–z 0–9 - _ . ! ~ * ' ( )
 *     ; / ? : @ & = + $ , #
 *
 * Matching Javascript's encodeURI()
 */
char *encodeURI(const char *text){
    return __encode_by_map(text, bitmap_encodeURI);
}

/*
 * Encodes everything EXCEPT
 *     A–Z a–z 0–9 - _ . ! ~ * ' ( )
 *
 * Matching Javascript's encodeURIComponent()
 */
char *encodeURIComponent(const char *text){
    return __encode_by_map(text, bitmap_encodeURIComponent);
}

#ifdef NON_STANDARD_FUNC
/*
 * Encodes everything EXCEPT
 *     A–Z a–z 0–9
 */
char *encodeNonCharNum(const char* text)
{
    return __encode_by_map(text, bitmap_encodeNonCharNum);
}
#endif

/* Invert function to decode() which encodes EVERYTHING!*/
char *encode(const char* text)
{
    // allocate memory for the worst possible case (all characters need to be encoded)
    const size_t len_text = strlen(text);
    char *encodedText = (char *)malloc(sizeof(char)*len_text*3+1);
    
    const char *hex = "0123456789abcdef";
    int pos = 0;
    for (size_t i = 0; i < len_text; i++) {
        if (0) {
                encodedText[pos++] = text[i];
            } else {
                encodedText[pos++] = '%';
                encodedText[pos++] = hex[text[i] >> 4];
                encodedText[pos++] = hex[text[i] & 15];
            }
    }
    encodedText[pos] = '\0';
    return encodedText;
}

char *__decode_by_map(const char *text, const unsigned char *ascii_includes){
    // allocate memory for the worst possible case (no length change)
    const size_t len_text = strlen(text);
    char *decodedText = (char *)malloc(sizeof(char)*len_text*1+1);
    
    int pos = 0;
    for (size_t i = 0; i < len_text; i++) {
        if (text[i] == '%' && i < len_text - 2){
            char b1 = text[i+1];
            char b2 = text[i+2];
            char d1, d2;
             // both bytes should be in [48-57] (0-9) or [97,102] (a-f) or [65,70] (A-F)
             if (b1 >= 48 && b1 <= 57){
                 d1 = b1 - 48;
             }else if ( b1 >= 97 && b1 <= 102){
                 d1 = b1 - 97 + 10;
             }else if ( b1 >= 65 && b1 <= 70){
                 d1 = b1 - 65 + 10;
             }else{ // decoding not possible
                 decodedText[pos++] = text[i];
                 continue;
             }
             if (b2 >= 48 && b2 <= 57){
                 d2 = b2 - 48;
             }else if ( b2 >= 97 && b2 <= 102){
                 d2 = b2 - 97 + 10;
             }else if ( b2 >= 65 && b2 <= 70){
                 d2 = b2 - 65 + 10;
             }else{ // decoding not possible
                 decodedText[pos++] = text[i];
                 decodedText[pos++] = text[i+1]; // This was hex.
                 i += 1;
                 continue;
             }

             char c = ((d1 << 4) | d2); // >= 0
             // Check if char isn't in map of encoded chars.
             if (!ascii_includes[c/8] & (1<<(c%8)) ) {
                 /* Here, we already know '%' != text[j] for j=i+1,i+2
                  * and can consume three bytes. */
                 decodedText[pos++] = text[i];
                 decodedText[pos++] = text[i+1];
                 decodedText[pos++] = text[i+2];
                 i += 2;
                 continue;
             }
             
             // Decoding possible: Consume tree bytes and produce one.
             decodedText[pos++] = c;
             i += 2;
        }else{
            decodedText[pos++] = text[i];
        }
    }
    decodedText[pos] = '\0';
    return decodedText;

}

char *decodeURI(const char* text)
{
    return __decode_by_map(text, bitmap_encodeURI);
}

char *decodeURIComponent(const char* text)
{
    return __decode_by_map(text, bitmap_encodeURIComponent);
}

#ifdef NON_STANDARD_FUNC
char *decodeNonCharNum(const char* text)
{
    return __decode_by_map(text, bitmap_encodeNonCharNum);
}
#endif

char *decode(const char* text)
{
    // allocate memory for the worst possible case (no length change)
    const size_t len_text = strlen(text);
    char *decodedText = (char *)malloc(sizeof(char)*len_text*1+1);
    
    int pos = 0;
    for (size_t i = 0; i < len_text; i++) {
        if (text[i] == '%' && i < len_text - 2){
            char b1 = text[i+1];
            char b2 = text[i+2];
            char d1, d2;
             // both bytes should be in [48-57] (0-9) or [97,102] (a-f) or [65,70] (A-F)
             if (b1 >= 48 && b1 <= 57){
                 d1 = b1 - 48;
             }else if ( b1 >= 97 && b1 <= 102){
                 d1 = b1 - 97 + 10;
             }else if ( b1 >= 65 && b1 <= 70){
                 d1 = b1 - 65 + 10;
             }else{ // decoding not possible
                 decodedText[pos++] = text[i];
                 continue;
             }
             if (b2 >= 48 && b2 <= 57){
                 d2 = b2 - 48;
             }else if ( b2 >= 97 && b2 <= 102){
                 d2 = b2 - 97 + 10;
             }else if ( b2 >= 65 && b2 <= 70){
                 d2 = b2 - 65 + 10;
             }else{ // decoding not possible
                 decodedText[pos++] = text[i];
                 continue;
             }
             // Decoding possible: Consume tree bytes and produce one.
             decodedText[pos++] = ((d1 << 4) | d2) ;
             i += 2;
        }else{
            decodedText[pos++] = text[i];
        }
    }
    decodedText[pos] = '\0';
    return decodedText;
}
