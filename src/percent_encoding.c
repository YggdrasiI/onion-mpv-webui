#include "percent_encoding.h"

// Maps generated by gen_encoding_maps.py
unsigned char bitmap_encodeURI[16] = {
                /*   7    6    5    4    3    2    1    0      + */
    0b11111111, /* \x07 \x06 \x05 \x04 \x03 \x02 \x01 \x00 |   0 */
    0b11111111, /* \x0f \x0e  \r  \x0c \x0b  \n   \t  \x08 |   8 */
    0b11111111, /* \x17 \x16 \x15 \x14 \x13 \x12 \x11 \x10 |  16 */
    0b11111111, /* \x1f \x1e \x1d \x1c \x1b \x1a \x19 \x18 |  24 */
    0b00100101, /*  '    &    %    $    #    "    !        |  32 */
    0b00000000, /*  /    .    -    ,    +    *    )    (   |  40 */
    0b00000000, /*  7    6    5    4    3    2    1    0   |  48 */
    0b01010000, /*  ?    >    =    <    ;    :    9    8   |  56 */
    0b00000000, /*  G    F    E    D    C    B    A    @   |  64 */
    0b00000000, /*  O    N    M    L    K    J    I    H   |  72 */
    0b00000000, /*  W    V    U    T    S    R    Q    P   |  80 */
    0b01111000, /*  _    ^    ]    \\   [    Z    Y    X   |  88 */
    0b00000001, /*  g    f    e    d    c    b    a    `   |  96 */
    0b00000000, /*  o    n    m    l    k    j    i    h   | 104 */
    0b00000000, /*  w    v    u    t    s    r    q    p   | 112 */
    0b10111000, /* \x7f  ~    }    |    {    z    y    x   | 120 */
};              /* Swapped endianess                             */

unsigned char bitmap_encodeURIComponent[16] = {
                /*   7    6    5    4    3    2    1    0      + */
    0b11111111, /* \x07 \x06 \x05 \x04 \x03 \x02 \x01 \x00 |   0 */
    0b11111111, /* \x0f \x0e  \r  \x0c \x0b  \n   \t  \x08 |   8 */
    0b11111111, /* \x17 \x16 \x15 \x14 \x13 \x12 \x11 \x10 |  16 */
    0b11111111, /* \x1f \x1e \x1d \x1c \x1b \x1a \x19 \x18 |  24 */
    0b01111101, /*  '    &    %    $    #    "    !        |  32 */
    0b10011000, /*  /    .    -    ,    +    *    )    (   |  40 */
    0b00000000, /*  7    6    5    4    3    2    1    0   |  48 */
    0b11111100, /*  ?    >    =    <    ;    :    9    8   |  56 */
    0b00000001, /*  G    F    E    D    C    B    A    @   |  64 */
    0b00000000, /*  O    N    M    L    K    J    I    H   |  72 */
    0b00000000, /*  W    V    U    T    S    R    Q    P   |  80 */
    0b01111000, /*  _    ^    ]    \\   [    Z    Y    X   |  88 */
    0b00000001, /*  g    f    e    d    c    b    a    `   |  96 */
    0b00000000, /*  o    n    m    l    k    j    i    h   | 104 */
    0b00000000, /*  w    v    u    t    s    r    q    p   | 112 */
    0b10111000, /* \x7f  ~    }    |    {    z    y    x   | 120 */
};              /* Swapped endianess                             */

unsigned char bitmap_encodeAllReserved[16] = {
                /*   7    6    5    4    3    2    1    0      + */
    0b11111111, /* \x07 \x06 \x05 \x04 \x03 \x02 \x01 \x00 |   0 */
    0b11111111, /* \x0f \x0e  \r  \x0c \x0b  \n   \t  \x08 |   8 */
    0b11111111, /* \x17 \x16 \x15 \x14 \x13 \x12 \x11 \x10 |  16 */
    0b11111111, /* \x1f \x1e \x1d \x1c \x1b \x1a \x19 \x18 |  24 */
    0b11111111, /*  '    &    %    $    #    "    !        |  32 */
    0b10011111, /*  /    .    -    ,    +    *    )    (   |  40 */
    0b00000000, /*  7    6    5    4    3    2    1    0   |  48 */
    0b11111100, /*  ?    >    =    <    ;    :    9    8   |  56 */
    0b00000001, /*  G    F    E    D    C    B    A    @   |  64 */
    0b00000000, /*  O    N    M    L    K    J    I    H   |  72 */
    0b00000000, /*  W    V    U    T    S    R    Q    P   |  80 */
    0b01111000, /*  _    ^    ]    \\   [    Z    Y    X   |  88 */
    0b00000001, /*  g    f    e    d    c    b    a    `   |  96 */
    0b00000000, /*  o    n    m    l    k    j    i    h   | 104 */
    0b00000000, /*  w    v    u    t    s    r    q    p   | 112 */
    0b10111000, /* \x7f  ~    }    |    {    z    y    x   | 120 */
};              /* Swapped endianess                             */

unsigned char bitmap_encodeUnixPath[16] = {
                /*   7    6    5    4    3    2    1    0      + */
    0b11111111, /* \x07 \x06 \x05 \x04 \x03 \x02 \x01 \x00 |   0 */
    0b11111111, /* \x0f \x0e  \r  \x0c \x0b  \n   \t  \x08 |   8 */
    0b11111111, /* \x17 \x16 \x15 \x14 \x13 \x12 \x11 \x10 |  16 */
    0b11111111, /* \x1f \x1e \x1d \x1c \x1b \x1a \x19 \x18 |  24 */
    0b11111111, /*  '    &    %    $    #    "    !        |  32 */
    0b00011111, /*  /    .    -    ,    +    *    )    (   |  40 */
    0b00000000, /*  7    6    5    4    3    2    1    0   |  48 */
    0b11111100, /*  ?    >    =    <    ;    :    9    8   |  56 */
    0b00000001, /*  G    F    E    D    C    B    A    @   |  64 */
    0b00000000, /*  O    N    M    L    K    J    I    H   |  72 */
    0b00000000, /*  W    V    U    T    S    R    Q    P   |  80 */
    0b01111000, /*  _    ^    ]    \\   [    Z    Y    X   |  88 */
    0b00000001, /*  g    f    e    d    c    b    a    `   |  96 */
    0b00000000, /*  o    n    m    l    k    j    i    h   | 104 */
    0b00000000, /*  w    v    u    t    s    r    q    p   | 112 */
    0b10111000, /* \x7f  ~    }    |    {    z    y    x   | 120 */
};              /* Swapped endianess                             */

unsigned char bitmap_decodeText[16] = {
                /*   7    6    5    4    3    2    1    0      + */
    0b00000000, /* \x07 \x06 \x05 \x04 \x03 \x02 \x01 \x00 |   0 */
    0b00100110, /* \x0f \x0e  \r  \x0c \x0b  \n   \t  \x08 |   8 */
    0b00000000, /* \x17 \x16 \x15 \x14 \x13 \x12 \x11 \x10 |  16 */
    0b00000000, /* \x1f \x1e \x1d \x1c \x1b \x1a \x19 \x18 |  24 */
    0b11111111, /*  '    &    %    $    #    "    !        |  32 */
    0b11111111, /*  /    .    -    ,    +    *    )    (   |  40 */
    0b11111111, /*  7    6    5    4    3    2    1    0   |  48 */
    0b11111111, /*  ?    >    =    <    ;    :    9    8   |  56 */
    0b11111111, /*  G    F    E    D    C    B    A    @   |  64 */
    0b11111111, /*  O    N    M    L    K    J    I    H   |  72 */
    0b11111111, /*  W    V    U    T    S    R    Q    P   |  80 */
    0b11111111, /*  _    ^    ]    \\   [    Z    Y    X   |  88 */
    0b11111111, /*  g    f    e    d    c    b    a    `   |  96 */
    0b11111111, /*  o    n    m    l    k    j    i    h   | 104 */
    0b11111111, /*  w    v    u    t    s    r    q    p   | 112 */
    0b01111111, /* \x7f  ~    }    |    {    z    y    x   | 120 */
};              /* Swapped endianess                             */


char *__encode_by_map(const char *text, const unsigned char *ascii_includes){
    // allocate memory for the worst possible case (all characters need to be encoded)
    const size_t len_text = strlen(text);
    char * const encodedText = (char *)malloc(sizeof(char)*len_text*3+1);

    const char *hex = "0123456789abcdef";
    int pos = 0;
    for (size_t i = 0; i < len_text; i++) {
        signed char c = (signed char) text[i];
        if (c < 0 || ! (ascii_includes[c/8] & (1<<(c%8))) ) {
                encodedText[pos++] = text[i];
            } else {
                encodedText[pos++] = '%';
                encodedText[pos++] = hex[c >> 4];
                encodedText[pos++] = hex[c & 15];
            }
    }
    encodedText[pos] = '\0';
    return encodedText;
}

/*
 * Encodes everything EXCEPT
 *     A–Z a–z 0–9 - _ . ! ~ * ' ( )
 *     ; / ? : @ & = + $ , #
 *
 * Matching Javascript's encodeURI()
 */
char *encodeURI(const char *text){
    return __encode_by_map(text, bitmap_encodeURI);
}

/*
 * Encodes everything EXCEPT
 *     A–Z a–z 0–9 - _ . ! ~ * ' ( )
 *
 * Matching Javascript's encodeURIComponent()
 */
char *encodeURIComponent(const char *text){
    return __encode_by_map(text, bitmap_encodeURIComponent);
}

/*
 *  Encodes all special chars except '-', '_', '~', '.'
 */
char *encodeAllReserved(const char* text)
{
    return __encode_by_map(text, bitmap_encodeAllReserved);
}

/*
 * For unix file paths
 */
char *encodeUnixPath(const char *text){
    return __encode_by_map(text, bitmap_encodeUnixPath);
}


/* Invert function to decode() which encodes EVERYTHING!*/
char *encode(const char* text)
{
    // allocate memory for the worst possible case (all characters need to be encoded)
    const size_t len_text = strlen(text);
    char *encodedText = (char *)malloc(sizeof(char)*len_text*3+1);

    const char *hex = "0123456789abcdef";
    int pos = 0;
    for (size_t i = 0; i < len_text; i++) {
        if (0) {
                encodedText[pos++] = text[i];
            } else {
                encodedText[pos++] = '%';
                encodedText[pos++] = hex[text[i] >> 4];
                encodedText[pos++] = hex[text[i] & 15];
            }
    }
    encodedText[pos] = '\0';
    return encodedText;
}

char *__decode_by_map(const char *text, const unsigned char *ascii_includes){
    // allocate memory for the worst possible case (no length change)
    const size_t len_text = strlen(text);
    char *decodedText = (char *)malloc(sizeof(char)*len_text*1+1);

    int pos = 0;
    for (size_t i = 0; i < len_text; i++) {
        if (text[i] == '%' && i < len_text - 2){
            char b1 = text[i+1];
            char b2 = text[i+2];
            char d1, d2;
             // both bytes should be in [48-57] (0-9) or [97,102] (a-f) or [65,70] (A-F)
             if (b1 >= 48 && b1 <= 57){
                 d1 = b1 - 48;
             }else if ( b1 >= 97 && b1 <= 102){
                 d1 = b1 - 97 + 10;
             }else if ( b1 >= 65 && b1 <= 70){
                 d1 = b1 - 65 + 10;
             }else{ // decoding not possible
                 decodedText[pos++] = text[i];
                 continue;
             }
             if (b2 >= 48 && b2 <= 57){
                 d2 = b2 - 48;
             }else if ( b2 >= 97 && b2 <= 102){
                 d2 = b2 - 97 + 10;
             }else if ( b2 >= 65 && b2 <= 70){
                 d2 = b2 - 65 + 10;
             }else{ // decoding not possible
                 decodedText[pos++] = text[i];
                 decodedText[pos++] = text[i+1]; // This was hex.
                 i += 1;
                 continue;
             }

             char c = ((d1 << 4) | d2); // >= 0
             // Check if char isn't in map of encoded chars.
             if (!ascii_includes[c/8] & (1<<(c%8)) ) {
                 /* Here, we already know '%' != text[j] for j=i+1,i+2
                  * and can consume three bytes. */
                 decodedText[pos++] = text[i];
                 decodedText[pos++] = text[i+1];
                 decodedText[pos++] = text[i+2];
                 i += 2;
                 continue;
             }

             // Decoding possible: Consume tree bytes and produce one.
             decodedText[pos++] = c;
             i += 2;
        }else{
            decodedText[pos++] = text[i];
        }
    }
    decodedText[pos] = '\0';
    return decodedText;

}

char *decodeURI(const char* text)
{
    return __decode_by_map(text, bitmap_encodeURI);
}

char *decodeURIComponent(const char* text)
{
    return __decode_by_map(text, bitmap_encodeURIComponent);
}

char *decodeAllReserved(const char* text)
{
    return __decode_by_map(text, bitmap_encodeAllReserved);
}

char *decodeText(const char* text)
{
    return __decode_by_map(text, bitmap_decodeText);
}

char *decode(const char* text)
{
    // allocate memory for the worst possible case (no length change)
    const size_t len_text = strlen(text);
    char *decodedText = (char *)malloc(sizeof(char)*len_text*1+1);

    int pos = 0;
    for (size_t i = 0; i < len_text; i++) {
        if (text[i] == '%' && i < len_text - 2){
            char b1 = text[i+1];
            char b2 = text[i+2];
            char d1, d2;
             // both bytes should be in [48-57] (0-9) or [97,102] (a-f) or [65,70] (A-F)
             if (b1 >= 48 && b1 <= 57){
                 d1 = b1 - 48;
             }else if ( b1 >= 97 && b1 <= 102){
                 d1 = b1 - 97 + 10;
             }else if ( b1 >= 65 && b1 <= 70){
                 d1 = b1 - 65 + 10;
             }else{ // decoding not possible
                 decodedText[pos++] = text[i];
                 continue;
             }
             if (b2 >= 48 && b2 <= 57){
                 d2 = b2 - 48;
             }else if ( b2 >= 97 && b2 <= 102){
                 d2 = b2 - 97 + 10;
             }else if ( b2 >= 65 && b2 <= 70){
                 d2 = b2 - 65 + 10;
             }else{ // decoding not possible
                 decodedText[pos++] = text[i];
                 continue;
             }
             // Decoding possible: Consume tree bytes and produce one.
             decodedText[pos++] = ((d1 << 4) | d2) ;
             i += 2;
        }else{
            decodedText[pos++] = text[i];
        }
    }
    decodedText[pos] = '\0';
    return decodedText;
}
