From 3b84c9d979664d61e7e0b5c0b40e034a556e2b07 Mon Sep 17 00:00:00 2001
From: Olaf Schulz <olaf_schulz@posteo.de>
Date: Thu, 19 Nov 2020 12:43:59 +0100
Subject: [PATCH 3/5] Extend for loops in otemplate by meta variables
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

In templates it would be useful to compare the current
loop index with a value.

Simply adding a 'loop variable' to the looping dict is problematic
because the sorting order may differ between filling and reading
of the dict.

Problematic example:
 C-Code:
    onion_dict *files = onion_dict_new();
    onion_dict_add(d, "files", files, OD_DICT | OD_FREE_VALUE);
    int loop0=0;
    while ((de = readdir(dir))) {

      onion_dict *file = onion_dict_new();
      onion_dict_add(files, de->d_name, file,
	OD_DUP_KEY | OD_DICT | OD_FREE_VALUE);

      [...]
      char tmp[22];
      onion_dict_add(file, "loop0", tmp, OD_DUP_VALUE);
      loop0 += 1;
    }
    closedir(dir);

 Template:
  {% for file in files %}
    {{ loop0 }}
  {% endfor %}

  Because 'readdir' returns no sorted data, the template loop
  is not 0, 1, â€¦ but in random order

This commit adds the meta data variables 'loop0' and 'loop' to for-tags
in templates. They can be used as 'meta.loop0', 'meta.loop' and allows
the detection of the first loop run, ect.
In templates, the variables could only be compared with strings, not numbers.
---
 tools/otemplate/otemplate.c    | 11 +++++++++--
 tools/otemplate/tag_builtins.c | 16 ++++++++++++----
 tools/otemplate/variables.c    | 13 +++++++++++++
 3 files changed, 34 insertions(+), 6 deletions(-)

diff --git a/tools/otemplate/otemplate.c b/tools/otemplate/otemplate.c
index bd1576e..6a7c8e4 100644
--- a/tools/otemplate/otemplate.c
+++ b/tools/otemplate/otemplate.c
@@ -228,16 +228,23 @@ int work(const char *infilename, const char *outfilename,
   }
 
   fprintf(status.out,
-          "/** Autogenerated by otemplate v. 0.2.0 */\n"
+          "/** Autogenerated by otemplate v. 0.2.1 */\n"
           "\n"
           "#include <libintl.h>\n"
           "#include <string.h>\n\n"
           "#include <onion/onion.h>\n"
           "#include <onion/dict.h>\n"
           "\n"
+          "typedef struct loop_meta_t{\n"
+          "	int loop0;\n"
+          "	int loop;\n"
+          "}loop_meta;\n"
+          " static loop_meta ONION_TEMPLATE_META_INIT = {.loop0 = -1, .loop = 0 };\n"
+          "\n"
           "typedef struct dict_res_t{\n"
           "	onion_dict *dict;\n"
-          "	onion_response *res;\n" "}dict_res;\n" "\n" "\n");
+          "	onion_response *res;\n"
+          "	loop_meta meta;\n" "}dict_res;\n" "\n" "\n");
 
   functions_write_declarations_assets(&status, assets);
 
diff --git a/tools/otemplate/tag_builtins.c b/tools/otemplate/tag_builtins.c
index 4cc9864..fa61f4a 100644
--- a/tools/otemplate/tag_builtins.c
+++ b/tools/otemplate/tag_builtins.c
@@ -93,23 +93,31 @@ void tag_for(parser_status * st, list * l) {
   function_add_code(st,
                     "    onion_dict *tmpcontext=onion_dict_hard_dup(context);\n"
                     "    if (loopdict){\n"
-                    "      dict_res dr={ .dict = tmpcontext, .res=res };\n"
+                    "      dict_res dr={ .dict = tmpcontext, .res=res,"
+                    " .meta= ONION_TEMPLATE_META_INIT };\n"
+                    /* Setup of meta vars for 'tag_for' */
+                    "      dr.meta.loop0 = -1;\n"
+                    "      dr.meta.loop = 0;\n"
                     "      onion_dict_preorder(loopdict, ");
   function_data *d = function_new(st, NULL);
   d->signature = "dict_res *dr, const char *key, const void *value, int flags";
 
   function_add_code(st,
-                    "  onion_dict_add(dr->dict, \"%s\", value, OD_DUP_VALUE|OD_REPLACE|(flags&OD_TYPE_MASK));\n",
+                    "  onion_dict_add(dr->dict, \"%s\", value, OD_DUP_VALUE|OD_REPLACE|(flags&OD_TYPE_MASK));\n"
+                    /* Change of meta vars for 'tag_for' loop step. */
+                    "  dr->meta.loop0++;\n"
+                    "  dr->meta.loop++;\n",
                     tag_value_arg(l, 1));
 
-  function_new(st, NULL);
+  function_data *d2 = function_new(st, NULL);
+  d2->signature = "onion_dict *context, onion_response *res, loop_meta *meta";
 }
 
 /// Ends a for
 void tag_endfor(parser_status * st, list * l) {
   // First the preorder function
   function_data *d = function_pop(st);
-  function_add_code(st, "  %s(dr->dict, dr->res);\n", d->id);
+  function_add_code(st, "  %s(dr->dict, dr->res, &dr->meta);\n", d->id);
 
   // Now the normal code
   d = function_pop(st);
diff --git a/tools/otemplate/variables.c b/tools/otemplate/variables.c
index 4e1ba75..ca0c669 100644
--- a/tools/otemplate/variables.c
+++ b/tools/otemplate/variables.c
@@ -88,6 +88,19 @@ void variable_solve(parser_status * st, const char *data, const char *tmpname,
                         "    %s=onion_dict_get_dict(context, %s);\n", tmpname,
                         s);
     free(s);
+  } else if (parts->head && parts->head->next
+      && 0 == strcmp(onion_block_data(parts->head->data), "meta")) {
+    const char *meta_var = onion_block_data(parts->head->next->data);
+    if (0 == strcmp(meta_var, "loop0") ||
+        0 == strcmp(meta_var, "loop")  )
+    {
+      function_add_code(st,
+          "    char number_%1$s[22];\n %1$s=&number_%1$s[0];\n",
+          tmpname);
+      function_add_code(st,
+          "    snprintf(number_%1$s, 22, \"%%d\", (meta->%2$s));\n",
+          tmpname, meta_var);
+    }
   } else {
     if (type == STRING)
       function_add_code(st, "    %s=onion_dict_rget(context", tmpname);
-- 
2.25.1

